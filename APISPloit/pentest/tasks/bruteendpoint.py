
from celery import shared_task
import requests, json
from pentest.models import Test, Payload
from datetime import datetime
import concurrent.futures


def getRequest(url, headers, sc, id) :
    r = requests.get(url, headers=headers)
    if r.status_code in sc :
        Payload.objects.create(payload_string= url, response_code = r.status_code, request_header=str(json.dumps(dict(headers))), test_id=id, response_header=str(json.dumps(dict(r.headers))),response_body = str(r.text))

def postRequest(url,headers,sc,data_format,body,id) :
    if data_format == "JSON" :
        body = json.loads(body) 
        r = requests.post(url, json=body, headers=headers)
        
        if r.status_code in sc :
            Payload.objects.create(payload_string=url, response_code = r.status_code, request_header=str(json.dumps(dict(headers))), request_body = str(body), test_id=id, response_header=str(json.dumps(dict(r.headers))),response_body = str(r.text))
    elif data_format == "XML" :
        headers['Content-Type'] = "application/xml"
        r = requests.post(url, data = body, headers=headers)
        
        if r.status_code in sc :
            Payload.objects.create(payload_string=url, response_code = r.status_code, request_header=str(json.dumps(dict(headers))), request_body = str(body), test_id=id, response_header=str(json.dumps(dict(r.headers))),response_body = str(r.text))

def putRequest(url,headers,sc,data_format,body,id) :
    if data_format == "JSON" : 
        body = json.loads(body) 
        r = requests.put(url, json=body, headers=headers)
        if r.status_code in sc :
            Payload.objects.create(payload_string=url, response_code = r.status_code, request_header=str(json.dumps(dict(headers))), request_body = str(body), test_id=id, response_header=str(json.dumps(dict(r.headers))),response_body = str(r.text))
    elif data_format == "XML" :
        headers['Content-Type'] = "application/xml"
        r = requests.put(url, data = body, headers=headers)
        if r.status_code in sc :
            Payload.objects.create(payload_string=url, response_code = r.status_code, request_header=str(json.dumps(dict(headers))), request_body = str(body), test_id=id, response_header=str(json.dumps(dict(r.headers))),response_body = str(r.text))

def deleteRequest(url,headers,sc,data_format,body,id) :
    if data_format == "JSON" : 
        body = json.loads(body) 
        r = requests.delete(url, json=body, headers=headers)
        if r.status_code in sc :
            Payload.objects.create(payload_string=url, response_code = r.status_code, request_header=str(json.dumps(dict(headers))), request_body = str(body), test_id=id, response_header=str(json.dumps(dict(r.headers))),response_body = str(r.text))
    elif data_format == "XML" :
        headers['Content-Type'] = "application/xml"
        r = requests.delete(url, data = body, headers=headers)
        if r.status_code in sc :
            Payload.objects.create(payload_string=url, response_code = r.status_code, request_header=str(json.dumps(dict(headers))), request_body = str(body), test_id=id, response_header=str(json.dumps(dict(r.headers))),response_body = str(r.text))

def patchRequest(url,headers,sc,data_format,body,id) :
    if data_format == "JSON" : 
        body = json.loads(body) 
        r = requests.patch(url, json=body, headers=headers)
        if r.status_code in sc :
            Payload.objects.create(payload_string=url, response_code = r.status_code, request_header=str(json.dumps(dict(headers))), request_body = str(body), test_id=id, response_header=str(json.dumps(dict(r.headers))),response_body = str(r.text))
    elif data_format == "XML" :
        headers['Content-Type'] = "application/xml"
        r = requests.patch(url, data = body, headers=headers)
        if r.status_code in sc :
            Payload.objects.create(payload_string=url, response_code = r.status_code, request_header=str(json.dumps(dict(headers))), request_body = str(body), test_id=id, response_header=str(json.dumps(dict(r.headers))),response_body = str(r.text))



@shared_task
def BruteEndpoint(url, headers, request_method, sc, data_format, body, id):
    print("data nih " ,url,headers,request_method, sc, data_format,body,id)
    with open('pentest/helper/endpoints.txt') as f :
        data = f.read()
        data = data.splitlines()

    urls = []
    for d in data : 
        if url[-1] == "/" :
            u = url + d
            urls.append(u)
        else :
            u = url + "/" + d
            urls.append(u)
    
    status_codes = [200]
    sc = sc.split(',')
    
    try :
        for s in sc :
            status_codes.append(int(s.replace(" ", "")))

    except :
        pass


    if request_method == "get" :                          
        with concurrent.futures.ThreadPoolExecutor() as executor:
            results = [executor.submit(getRequest,url,headers, status_codes,id) for url in urls]
        
        Test.objects.filter(pk=id).update(end_time=datetime.now())

    elif request_method == "post":
        with concurrent.futures.ThreadPoolExecutor() as executor:
            results = [executor.submit(postRequest,url,headers, status_codes, data_format, body, id) for url in urls]

        Test.objects.filter(pk=id).update(end_time=datetime.now())

    elif request_method == "put":
        with concurrent.futures.ThreadPoolExecutor() as executor:
            results = [executor.submit(putRequest,url,headers, status_codes, data_format, body, id) for url in urls]

        Test.objects.filter(pk=id).update(end_time=datetime.now())

    elif request_method == "delete":
        with concurrent.futures.ThreadPoolExecutor() as executor:
            results = [executor.submit(deleteRequest,url,headers, status_codes, data_format, body, id) for url in urls]

        Test.objects.filter(pk=id).update(end_time=datetime.now())

    elif request_method == "patch":
        with concurrent.futures.ThreadPoolExecutor() as executor:
            results = [executor.submit(patchRequest,url,headers, status_codes, data_format, body, id) for url in urls]

        Test.objects.filter(pk=id).update(end_time=datetime.now())