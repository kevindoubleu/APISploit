$(document).ready(() => {

    const disableVuln = () => {
        $('#inlineCheckbox10').prop("disabled", false);
    }
    const enableVuln = () => {
        $('#inlineCheckbox10').prop("disabled", true);
    }
    const isChecked = () => {
        if($("#inlineCheckbox1").is(":checked")){
            $('#payloadType').css("display", "block");
            $('#wordlist').css("display", "block");
        }
        else{
            $('#payloadType').css("display", "none");
            $('#wordlist').css("display", "none");
        }
    }
    const hideIterator = () => {
        $('#numberIterator').css("display", "none");
        $('#wordlist').css("display", "block");
    }
    const showIterator = () => {
        $('#numberIterator').css("display", "block");
        $('#wordlist').css("display", "none");
    }

    const hideBody = () => {
        $('#bodyDiv').css("display", "none");
        $('#dataFormatDiv').css("display", "none");
    }

    const showBody = () => {
        $('#bodyDiv').css("display", "block");
        $('#dataFormatDiv').css("display", "block");
    }


    $("#xml").on("change", disableVuln);
    $("#json").on("change", enableVuln);
    $("#inlineCheckbox1").on("change", isChecked);
    $("#payloadOptions").change(function(){
        if($("#payloadOptions option:selected").val()== "wordlist"){
            hideIterator();
        }   
        else{
            showIterator();
        }
    })

    $("#method").change(function(){
        if($("#method option:selected").val() == "get"){
            hideBody();
        }
        else{
            showBody();
        }
    })
    
    
    $("#submit").click(() => {
        const api_url = "{{url}}";
        const url = $("#url").val();
        const method = $("#method").val();
        let headers = $("textarea#headers").val();

        if(!headers){
            headers = "{}";
        }
        try{
            headers = JSON.parse(headers);
        }
        catch(e){
            return swal("Error!", "Invalid JSON syntax on request headers", "error");
        }
        const dataFormat = $('input[name="dataFormat"]:checked').val();
        const vulns = [];
        [...document.querySelectorAll('input[name="vulns"]:checked')].forEach((v) => vulns.push(v.value));
        const body = $('#requestBody').val();

        //validation

        //check if url is empty or not
        if(!url){
            return swal("Error!", "URL cannot be empty", "error");
        }

        //check if vuln is selected or not
        if(vulns.length === 0){
            return swal("Error!", "Please select at least one vulnerabilty to scan", "error");
        }

        //check for injection markers
        if(vulns.includes("IDOR")){
            const markerOnUrl = url.includes("~");
            const markerOnBody = body.includes("~");
            const payloadType = $("#payloadOptions").val();
            
            if(payloadType === "numbers"){
                const fromVal = Number($("#fromVal").val());
                const toVal = Number($("#toVal").val());
                const stepVal = Number($("#stepVal").val());
                if(isNaN(fromVal) || isNaN(toVal) || isNaN(stepVal)){
                    return swal("Error!", "Invalid number settings", "error");
                }
            }
            if(payloadType === "wordlist"){
                let wordlist = $('#wordlistVal').val();
                if(wordlist.trim() === ""){
                    return swal("Error!", "Wordlist cannot be empty", "error");
                }
                wordlist = wordlist.split("\n");
                if(wordlist.length>100){
                    return swal("Error!", "Maximum number of words allowed is 100", "error");
                }
            }
            if(!markerOnUrl && !markerOnBody){
                return swal("Error!", "Please define the injection point by using ~ marker on the URL input or Request Body", "error");
            }
        }

        if(vulns.includes("SQLI")){
            const markerOnUrl = url.includes("*");
            const markerOnBody = body.includes("*");
            if(!markerOnUrl && !markerOnBody){
                return swal("Error!", "Please define the injection point by using * marker on the URL input or Request Body", "error");
            }
        }

        if(vulns.includes("NOSQLI")){
            const markerOnUrl = url.includes("@");
            const markerOnBody = body.includes("@");
            if(!markerOnUrl && !markerOnBody){
                return swal("Error!", "Please define the injection point by using @ marker on the URL input or Request Body", "error");
            }
        }
        
        if(vulns.includes("JWT")){
            if(!headers.Authorization){
                return swal("Error!", "Please define your JWT Token on Request Headers", "error");
            }
            let jwt = headers.Authorization.split(" ");
            if(jwt[0] !== "Bearer" || !headers.Authorization.includes(" ")){
                return swal("Error!", "Invalid JWT Format", "error");
            }
        }
        const sendData = async () => {
            //if vuln != IDOR
            let data = null;
            let fromVal = 0;
            let toVal = 0;
            let stepVal = 0;
            let wordlist = null;

            const payloadType = $("#payloadOptions").val();
            if(payloadType === "numbers"){
                fromVal = Number($("#fromVal").val());
                toVal = Number($("#toVal").val());
                stepVal = Number($("#stepVal").val());
            }
            else if(payloadType === "wordlist"){
                wordlist = $('#wordlistVal').val().split("\n");
            } 
            
            if(vulns.includes("IDOR") && payloadType === "numbers"){
                data = JSON.stringify({
                    url : url,
                    request_method : method,
                    headers : headers,
                    data_format : dataFormat,
                    vulns : vulns,
                    body : body,
                    payloadType : "numbers",
                    fromVal : fromVal,
                    toVal : toVal,
                    stepVal : stepVal
                })
            }
            else if(vulns.includes("IDOR") && payloadType === "wordlist"){
                data = JSON.stringify({
                    url : url,
                    request_method : method,
                    headers : headers,
                    data_format : dataFormat,
                    payloadType : "wordlist",
                    vulns : vulns,
                    body : body,
                    wordlist: wordlist
                }) 
            }
            else{
                data = JSON.stringify({
                    url : url,
                    request_method : method,
                    headers : headers,
                    data_format : dataFormat,
                    vulns : vulns,
                    body : body
                })
            }

            try{
                const req = await fetch(`http://${api_url}/`, {
                    method: "post",
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body : data
                });
                if(req.status == 200){
                    const resp = await req.json();
                    swal("Success!", resp.message, "success").then(result => {
                        window.location.href = "/";
                    })
                }
                else{
                    const resp = await req.json();
                    if(resp.message){
                        swal("Error!", resp.message, "error")
                    }
                    else{
                        swal("Error!", "An unexpected error has occured", "error")
                    }
                }
            }
            catch(err){
                return swal("Error!", err, "error");
            }
        }
        sendData();
    })
});